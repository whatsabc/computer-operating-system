## 2.1 进程

### 2.1.5 进程的状态

1. 运行态
2. 就绪态
3. 阻塞态

```
            运行
           /    \
         1/     3\2
         /        \
       阻塞-------就绪
              4
```

1. 进程因为等待输入而被阻塞
2. 调度程序选择另一个进程
3. 调度程序选择这个进程
4. 出现有效调度

### 2.1.6 进程的实现

操作系统维护着一张表格，叫**进程表**。每个进程占用一个进程表项（**进程控制块**）。该表项包含了进程状态的重要信息。包括程序计数器，堆栈指针，内存分配状况，所打开文件的状态，账号和调度信息。

## 2.2 线程

### 2.2.1 线程的使用

人们需要多线程的原因

在许多应用中同时发生着多种活动。其中某些活动随着时间的推移会被阻塞。通过将这些应用程序分解成可以准并行运行的多个顺序线程，程序设计模型会变得很简单。

线程比进程更轻量级更容易被创建，也更容易被撤销。

### 2.2.2 经典的线程模型

第一种是每个进程分别有一个线程，第二种是一个进程有多个线程，当多线程进程在单CPU系统中运行时，线程轮流运行。通过在不同线程之间快速切换，系统制造了不同的顺序进程并行运行的假象。

一个进程中的不同线程不像进程之间那样存在很大的独立性。所有的线程都有完全一样的地址空间，这意味着它们也共享同样的全局变量。由于各个线程都是可以访问进程地址空间中的每一个内存地址，所以一个线程可以读，写甚至清除另一个线程的堆栈。线程之间是没有保护的。这与不同进程之间是有差别的。

### 2.2.4 在用户空间中实现线程

有两种方式实现线程，用户空间和内核。也可以采用混合方式。

### 2.2.5 在内核中实现线程

### 2.2.6 混合实现

## 2.3 进程间通信

进程通信要解决下面三个问题

1. 一个进程如何把信息传递给第二个进程
2. 确保两个或者更多的进程在关键活动中不会出现交叉
3. 进程处理过程中的正确的顺序

管道（pipe）及命名管道（named pipe）：管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；

信号（signal）：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；

消息队列：消息队列是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息；

共享内存：可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等；

信号量：主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段；

套接字：这是一种更为一般得进程间通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛。

**线程同步的方式**

临界区：通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。

互斥量 ：为协调对一个共享资源的单独访问而设计，采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。互斥不仅能实现同一应用程序的公共资源安全共享，还能实现不同应用程序的公共资源安全共享。

信号量：为控制一个具有有限数量的用户资源而设计。它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量

事件(信号）：用来通知线程有一些事件已发生，从而启动后继任务的开始保持多线程同步，也可方便的实现多线程优先级的比较操作

## 2.4 调度

### 2.4.2 批处理系统中的调度

#### 1.先来先服务

队列实现，非抢占，先请求CPU的进程先分配到CPU，可以作为作业调度算法也可以作为进程调度算法；按作业或者进程到达的先后顺序依次调度，对于长作业比较有利；

#### 2.最短作业优先

作业调度算法，算法从就绪队列中选择估计时间最短的作业进行处理，直到得出结果或者无法继续执行，平均等待时间最短，但难以知道下一个CPU区间长度；缺点：不利于长作业；未考虑作业的重要性；运行时间是预估的，并不靠谱 ；

### 2.4.3 交互式系统中的调度

#### 1.时间片轮转调度算法(可抢占的)：

按到达的先后对进程放入队列中，然后给队首进程分配CPU时间片，时间片用完之后计时器发出中断，暂停当前进程并将其放到队列尾部，循环队列中没有进程被分配超过一个时间片的CPU时间，除非它是唯一可运行的进程。如果进程的CPU区间超过了一个时间片，那么该进程就被抢占并放回就绪队列。

#### 2.优先级调度算法(可以是抢占的，也可以是非抢占的)：

优先级越高越先分配到CPU，相同优先级先到先服务，存在的主要问题是：低优先级进程无穷等待CPU，会导致无穷阻塞或饥饿；
